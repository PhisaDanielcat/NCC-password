# A
# p=106697219132480173106064317148705638676529121742557567770857687729397446898790451577487723991083173010242416863238099716044775658681981821407922722052778958942891831033512463262741053961681512908218003840408526915629689432111480588966800949428079015682624591636010678691927285321708935076221951173426894836169

# q = 144819424465842307806353672547344125290716753535239658417883828941232509622838692761917211806963011168822281666033695157426515864265527046213326145174398018859056439431422867957079149967592078894410082695714160599647180947207504108618794637872261572262805565517756922288320779308895819726074229154002310375209

def bin_trans(a):
    b = bin(a)
    b1 = list(b)
    b1.reverse()  # 将二进制数倒置，b[0] 即表示最后一位
    b1.pop()
    b1.pop()

    b2 = ''.join(b1)  #
    return b2


def bin_trans_1(a):
    b = bin(a)
    b1 = list(b)
    b1.reverse()  # 将二进制数倒置，b[0] 即表示最后一位
    b1.pop()
    b1.pop()
    b1.reverse()
    b2 = ''.join(b1)  #
    return b2


def bin_list(b1):
    b1.reverse()  # 将二进制数倒置，b[0] 即表示最后一位
    b2 = ''.join(b1)  #
    return b2


C = 0
p = ['0', '0', '1', '0', '1', '1']  # 1011
A = bin_list(p)  # str
# A=11 #0111
# A_bin = bin_trans(A)
A_bin_1 = bin_trans_1(7)
print('二进制A-11:', A_bin_1)

B = 7
# B = q
B_bin = bin_trans(B)
B_bin_1 = bin_trans_1(B)
print('\n二进制B-2^8:', B_bin_1)

M = 13

M_bin = bin_trans(M)
M_bin_1 = bin_trans_1(M)
print('\n二进制M-13:', M_bin_1)

##########################
for a in A:
    if int(a) == 1:
        C += B
    else:
        C = C

    C_bin = bin_trans(C)  # 将C转为二进制字符串
    if int(C_bin[0]) == 1:
        C += M
        C //= 2
    else:
        C //= 2
    C_bin = bin_trans_1(C)
    print('C_each', C_bin)
#############################

print('\nC value:', C)

if C >= M:
    C1 = C - M
    print('\nC1 value:', C1)
else:
    C1 = C
    print('\nC1 value:', C1)

C_bin = bin_trans_1(C)  # str
print('\n二进制C:', C_bin)

C_bin = bin_trans_1(C1)  # str
print('\n二进制C1:', C_bin)

print('\n输出 A*B*2^-n mod M ')
